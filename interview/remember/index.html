<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>flutter vs react native | awesome-bookmarks</title>
    <meta name="description" content="个人收藏夹 beta">
    <link rel="icon" href="/awesome-bookmarks/favicon.ico">
    
    <link rel="preload" href="/awesome-bookmarks/assets/css/0.styles.6731ffee.css" as="style"><link rel="preload" href="/awesome-bookmarks/assets/js/app.14090382.js" as="script"><link rel="preload" href="/awesome-bookmarks/assets/js/60.0c78edc4.js" as="script"><link rel="prefetch" href="/awesome-bookmarks/assets/js/10.facfecf1.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/11.050612e5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/12.659cd2bc.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/13.40eb7674.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/14.85cbe56a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/15.623d025c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/16.3858966d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/17.077e5ba9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/18.cccaa83d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/19.bc94b840.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/2.00d0eedf.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/20.5e1b8a12.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/21.b497e7cb.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/22.92ecd2de.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/23.d3631828.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/24.d734e87d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/25.478acf62.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/26.fab00c70.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/27.6822a4e9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/28.8c7a77f6.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/29.9642e75a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/3.95ee515d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/30.a450cc04.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/31.03e8f05d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/32.7b9cc4d3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/33.3f162cfb.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/34.dbb98625.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/35.b6fd471d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/36.9150ff53.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/37.99c91358.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/38.54cd65c9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/39.764451d4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/4.c856b79a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/40.3851b4ca.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/41.8ca5d651.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/42.e5f54cf5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/43.182ef83d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/44.e5931353.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/45.382ece64.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/46.544cb487.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/47.886ffbea.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/48.d8503630.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/49.41389174.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/5.0b2a809f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/50.10a04f65.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/51.5d137992.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/52.2b26bbfe.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/53.b8d39cb8.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/54.d88d7c09.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/55.c76c1fc2.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/56.a852e2a2.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/57.5e3054c8.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/58.f7794a1c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/59.5fdc4aa3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/6.01c62d70.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/61.5705b185.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/62.4aaa6cfd.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/63.71987e1e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/64.3e60893b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/65.558f6360.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/66.3ca7cd53.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/67.cba72928.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/68.a9274fd0.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/7.54400708.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/8.5de36c56.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/9.0de68e52.js">
    <link rel="stylesheet" href="/awesome-bookmarks/assets/css/0.styles.6731ffee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome-bookmarks/" class="home-link router-link-active"><!----> <span class="site-name">awesome-bookmarks</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>面试</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/awesome-bookmarks/interview/" class="sidebar-link">面试</a></li><li><a href="/awesome-bookmarks/interview/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/awesome-bookmarks/interview/design-patterns.html" class="sidebar-link">设计模式</a></li><li><a href="/awesome-bookmarks/interview/js.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/network.html" class="sidebar-link">网络</a></li><li><a href="/awesome-bookmarks/interview/questions.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/react.html" class="sidebar-link">React</a></li><li><a href="/awesome-bookmarks/interview/vue.html" class="sidebar-link">Vue</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="js-基础"><a href="#js-基础" aria-hidden="true" class="header-anchor">#</a> JS 基础</h2> <h3 id="mouseenter-与-mouseover-区别"><a href="#mouseenter-与-mouseover-区别" aria-hidden="true" class="header-anchor">#</a> mouseenter 与 mouseover 区别</h3> <p>mouseenter 和 mouseleave 只有是 target element 的时候才会触发。 mouseover 和 mouseleave 会冒泡， 子元素也会触发。</p> <h3 id="e-target-与-e-currenttarget"><a href="#e-target-与-e-currenttarget" aria-hidden="true" class="header-anchor">#</a> e.target 与 e.currentTarget</h3> <p>e.target 指向触发事件监听的对象。</p> <p>e.currentTarget 指向添加监听事件的对象。</p> <h3 id="isnan-vs-number-isnan"><a href="#isnan-vs-number-isnan" aria-hidden="true" class="header-anchor">#</a> isNaN vs Number.isNaN</h3> <p>Number.isNaN() 方法确定传递的值是否为 NaN 和其类型是 Number。它是原始的全局 isNaN()的更强大的版本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="number-issafeinteger"><a href="#number-issafeinteger" aria-hidden="true" class="header-anchor">#</a> Number.isSafeInteger()</h3> <p>用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数</p> <p>安全整数范围为 -(253 - 1)到 253 - 1 之间的整数</p> <h3 id="tostring-valueof"><a href="#tostring-valueof" aria-hidden="true" class="header-anchor">#</a> toString valueOf</h3> <h3 id="addeventlistener"><a href="#addeventlistener" aria-hidden="true" class="header-anchor">#</a> addEventListener</h3> <ul><li>内存泄漏问题，只有保持静态函数引用才能被 <code>removeEventListener</code> 移除。</li> <li>passive: 提升页面滑动的流畅度</li> <li>useCapture: 事件捕获阶段触发 handler</li> <li>once: 只触发一次</li></ul> <h3 id="哪些事件不会事件冒泡"><a href="#哪些事件不会事件冒泡" aria-hidden="true" class="header-anchor">#</a> 哪些事件不会事件冒泡</h3> <ul><li>UI 事件
<ul><li>load</li> <li>unload</li> <li>scroll</li> <li>resize</li></ul></li> <li>焦点事件
<ul><li>blur</li> <li>focus</li></ul></li> <li>鼠标事件
<ul><li>mouseleave</li> <li>mouseenter</li></ul></li></ul> <h3 id="dispatchevent"><a href="#dispatchevent" aria-hidden="true" class="header-anchor">#</a> dispatchEvent</h3> <p>通过 dispatchEvent <code>new CustomEvent('myEvent', {detail:123});</code> 来触发自定义事件</p> <p>注意 new Event('build') vs new CustomEvent('build')</p> <h3 id="jsonp-原理"><a href="#jsonp-原理" aria-hidden="true" class="header-anchor">#</a> JSONP 原理</h3> <ul><li>在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。会有安全问题</li> <li>JSONP 在调用失败的时候不会返回各种 HTTP 状态码</li> <li>JSONP 只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求。</li></ul> <h3 id="_7-中类型"><a href="#_7-中类型" aria-hidden="true" class="header-anchor">#</a> 7 中类型</h3> <p>Number 、Null、Undefined、String、 Boolean 、Object 、Symbol</p> <h3 id="原生对象"><a href="#原生对象" aria-hidden="true" class="header-anchor">#</a> 原生对象</h3> <p><img src="https://wpimg.wallstcn.com/5c2fdb22-51ca-4206-918d-042ad5dbee1f.png" alt></p> <h3 id="null-vs-undefined"><a href="#null-vs-undefined" aria-hidden="true" class="header-anchor">#</a> null vs undefined</h3> <ul><li><p>null 表示&quot;没有对象&quot;，即该处不应该有值
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。</p></li> <li><p>undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。
（1）变量被声明了，但没有赋值时，就等于 undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
（3）对象没有赋值的属性，该属性的值为 undefined。
（4）函数没有返回值时，默认返回 undefined。</p></li></ul> <h3 id="为什么用-void-0-代替-undefined"><a href="#为什么用-void-0-代替-undefined" aria-hidden="true" class="header-anchor">#</a> 为什么用 void 0 代替 undefined</h3> <p>答案很简单，undefined 并不是保留词（reserved word），它只是全局对象的一个属性，在低版本 IE 中能被重写。
undefined 在 ES5 中已经是全局对象的一个只读（read-only）属性了，它不能被重写。但是在局部作用域中，还是可以被重写的。
那么，ES5 大环境下，void 0 就没有用武之地了吗？答案是否定的，用 void 0 代替 undefined 能节省不少字节的大小，事实上，不少 JavaScript 压缩工具在压缩过程中，正是将 undefined 用 void 0 代替掉了。不少基础库如 underscore、vue 都是用 void 0 的</p> <h3 id="charcodeat-vs-codepointat"><a href="#charcodeat-vs-codepointat" aria-hidden="true" class="header-anchor">#</a> charCodeAt vs codePointAt</h3> <p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。ES6 提供了 codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">'𠮷a'</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 134071</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 57271</span>

s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 97</span>
</code></pre></div><h3 id="精度问题"><a href="#精度问题" aria-hidden="true" class="header-anchor">#</a> 精度问题</h3> <p>es6 解决方案：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span>
</code></pre></div><p>IEEE 754
使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有 float 32 位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。</p> <p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p> <p>64 位比特又可分为三个部分：</p> <p>符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数
指数位 E：中间的 11 位存储指数（exponent），用来表示次方数
尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</p> <h3 id="object-create-vs-new-function"><a href="#object-create-vs-new-function" aria-hidden="true" class="header-anchor">#</a> Object.create vs new Function</h3> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 隐式构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回一个new</span>
<span class="token punctuation">}</span>
</code></pre></div><p>延伸： Object.create(null) vs {}</p> <p>https://panjiachen.github.io/awesome-bookmarks/blog/js.html#object-create-null-vs</p> <h3 id="普通函数-构造函数-箭头函数"><a href="#普通函数-构造函数-箭头函数" aria-hidden="true" class="header-anchor">#</a> 普通函数 构造函数 箭头函数</h3> <p>构造函数：</p> <ol><li>构造函数使用 new 关键字调用；普通函数不用 new 关键字调用；</li> <li>构造函数内部可以使用 this 关键字；普通函数内部不建议使用 this，因为这时候 this 指向的是 window 全局对象，这样无意间就会为 window 添加了一些全局变量或函数</li> <li>构造函数默认不用 return 返回值；普通函数一般都有 return 返回值</li> <li>构造函数首字母一般大写</li></ol> <p>箭头函数：</p> <ol><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li> <li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li> <li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li> <li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li></ol> <p>箭头函数不适用场景：</p> <ul><li>定义字面量方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token punctuation">{</span>
  array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sum</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> result <span class="token operator">+</span> item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
<span class="token comment">// Throws &quot;TypeError: Cannot read property 'reduce' of undefined&quot;</span>
calculator<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p>定义原型方法
如上同理</p></li> <li><p>是需要动态 this 的时候，也不应使用箭头函数。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> button<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'Clicked button'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码运行时，点击按钮会报错，因为 button 的监听函数是一个箭头函数，导致里面的 this 就是全局对象。如果改成普通函数，this 就会动态指向被点击的按钮对象。</p> <h3 id="类型判断"><a href="#类型判断" aria-hidden="true" class="header-anchor">#</a> 类型判断</h3> <h3 id="字符串有最大长度吗"><a href="#字符串有最大长度吗" aria-hidden="true" class="header-anchor">#</a> 字符串有最大长度吗</h3> <p>JS 字符串的长度受到下标限制。理论最大长度是 2^53-1（即 js 中可表达的最大安全整数）。</p> <h3 id="promise"><a href="#promise" aria-hidden="true" class="header-anchor">#</a> promise</h3> <h4 id="promise-resolve-一定是走-success-的么？"><a href="#promise-resolve-一定是走-success-的么？" aria-hidden="true" class="header-anchor">#</a> promise.resolve 一定是走 success 的么？</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error <span class="token operator">+</span> <span class="token string">'---error'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><h4 id="catch-的两种写法"><a href="#catch-的两种写法" aria-hidden="true" class="header-anchor">#</a> catch 的两种写法</h4> <p>Promise.prototype.catch 方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <h4 id="reject"><a href="#reject" aria-hidden="true" class="header-anchor">#</a> reject</h4> <p>reject 方法的作用，等同于抛出错误。
如果 Promise 状态已经变成 resolved，再抛出错误是无效的。
因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span> <span class="token comment">// 但还是会执行</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ok</span>
</code></pre></div><h4 id="allsettled-any"><a href="#allsettled-any" aria-hidden="true" class="header-anchor">#</a> allSettled,any</h4> <h4 id="generator"><a href="#generator" aria-hidden="true" class="header-anchor">#</a> generator</h4> <p>实现一个状态机</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">clock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tick!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tock!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="协程与子例程的差异"><a href="#协程与子例程的差异" aria-hidden="true" class="header-anchor">#</a> 协程与子例程的差异</h4> <p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。
协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p> <p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p> <p>http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E5%8D%8F%E7%A8%8B</p> <h3 id="宏观任务-微观任务"><a href="#宏观任务-微观任务" aria-hidden="true" class="header-anchor">#</a> 宏观任务 微观任务</h3> <p>由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p> <p>macro-task 包括：script(整体代码,主进程), setTimeout, setInterval, setImmediate, I/O, UI rendering, requestAnimationFrame。
micro-task 包括：process.nextTick, Promise 回调, Object.observe(已废弃), MutationObserver(DOM 变化监听器)</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>process.nextTick &gt; Promise.then &gt; MutationObserver</p> <p>延伸： vue 的 nextTick 是什么</p> <p>https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
https://juejin.im/post/59e85eebf265da430d571f89
https://juejin.im/post/5b35cdfa51882574c020d685</p> <h3 id="settimeout-setinterval-setimmediate-process-nexttick"><a href="#settimeout-setinterval-setimmediate-process-nexttick" aria-hidden="true" class="header-anchor">#</a> setTimeout setInterval setImmediate process.nextTick</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html</p> <p>注意</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>他们两者的执行顺序是不确定的
https://imweb.io/topic/5b148768d4c96b9b1b4c4ea1</p> <h3 id="settimeout-setinterval"><a href="#settimeout-setinterval" aria-hidden="true" class="header-anchor">#</a> setTimeout setInterval</h3> <p>对于 setInterval(fn,ms)来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。
一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了</p> <h3 id="event-loop"><a href="#event-loop" aria-hidden="true" class="header-anchor">#</a> event loop</h3> <p>timers
I/O callbacks
idle, prepare
poll
check
close callbacks</p> <h3 id="浏览器和-node-事件循环的区别"><a href="#浏览器和-node-事件循环的区别" aria-hidden="true" class="header-anchor">#</a> 浏览器和 Node 事件循环的区别</h3> <p>ibev 只能在 Unix 环境下运行。Windows 平台上与 kqueue(FreeBSD)或者(e)poll(Linux)等内核事件通知相应的机制是 IOCP。
libuv 提供了一个跨平台的抽象，由平台决定使用 libev 或 IOCP。</p> <p>们所看到的 node.js 单线程只是一个 js 主线程，本质上的异步操作还是由线程池完成的，node 将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的 I/O 操作，从而实现异步非阻塞 I/O，这便是 node 单线程和事件驱动的精髓之处了。</p> <h3 id="promise-原理"><a href="#promise-原理" aria-hidden="true" class="header-anchor">#</a> promise 原理</h3> <h3 id="async-await"><a href="#async-await" aria-hidden="true" class="header-anchor">#</a> async await</h3> <h2 id="webpack"><a href="#webpack" aria-hidden="true" class="header-anchor">#</a> webpack</h2> <h3 id="tree-shaking"><a href="#tree-shaking" aria-hidden="true" class="header-anchor">#</a> tree-shaking</h3> <h3 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeOf</h3> <p><a href="https://github.com/lifesinger/blog/issues/175" target="_blank" rel="noopener noreferrer">玉伯的分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>Object.prototype.toString.call(obj)</code></p> <p>instanceof 在 iframe 中会有问题。因为多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">''</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//false</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//true</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">//true</span>
</code></pre></div><p>Object.prototype.toString 的原理是：
在 toString 方法被调用时,会执行下面的操作步骤:
获取 this 对象的[[Class]]属性的值，es6 中已调整为 <code>NativeBrand</code>
由于是获取 this 的属性，所以必须要使用 call 或者 apply。</p> <h3 id="object-defineproperty"><a href="#object-defineproperty" aria-hidden="true" class="header-anchor">#</a> Object.defineProperty</h3> <p>value, writable,enumerable,configurable</p> <h3 id="proxy"><a href="#proxy" aria-hidden="true" class="header-anchor">#</a> proxy</h3> <p>双向绑定一般有如下几种方法：</p> <ul><li>发布-订阅 KnockoutJS</li> <li>脏检查 Angular</li> <li>Object.defineProperty Vue2.x</li> <li>proxy Vue3.x</li></ul> <p>Proxy 是 Object.defineProperty 的全方位加强版，可以直接监听对象而非属性，Proxy 可以直接监听数组的变化。
<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" target="_blank" rel="noopener noreferrer">实现双向绑定 Proxy 比 defineProperty 优劣如何<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="尾调用"><a href="#尾调用" aria-hidden="true" class="header-anchor">#</a> 尾调用</h3> <h3 id="new-做了些什么"><a href="#new-做了些什么" aria-hidden="true" class="header-anchor">#</a> new 做了些什么</h3> <p>四大步骤：</p> <p>1、创建一个空对象，并且 this 变量引用该对象，// lat target = {};</p> <p>2、继承了函数的原型。// target.proto = func.prototype;</p> <p>3、属性和方法被加入到 this 引用的对象中。并执行了该函数 func// func.call(target);</p> <p>4、新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果 func.call(target)返回的 res 是个对象或者 function 就返回它</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	lat target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> func<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
	<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="mvc-mvp-mvvm"><a href="#mvc-mvp-mvvm" aria-hidden="true" class="header-anchor">#</a> MVC MVP MVVM</h3> <ul><li>MVC: Controller 作为 View 层和 Model 层之间的连接点，连接 View -&gt; Model 之间的通信，Model 层的数据更新后会通知 View 层的视图更新并反馈给用户。View 和 Model 之间的强耦合度会加大调试时的难度。</li> <li>MVP: Presenter 承接起了 View 和 Model 之间的双向通信，View 与 Model 不发生联系，降低了耦合度且方便单元测试。</li> <li>MVVM: ViewModel 中构建了一组状态数据，作为 View 状态的抽象，通过双向数据绑定使 ViewModel 中的状态数据与 View 的显示状态保持一致，这样 View 的显示状态变化会自动更新 ViewModel 的状态数据，ViewModel 状态数据的变化也会自动同步 View 的显示状态。</li></ul> <h3 id="前端模块"><a href="#前端模块" aria-hidden="true" class="header-anchor">#</a> 前端模块</h3> <h3 id="fetch-优缺点"><a href="#fetch-优缺点" aria-hidden="true" class="header-anchor">#</a> fetch 优缺点</h3> <ul><li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
更好更方便的写法</li> <li>更加底层，提供的 API 丰富（request, response）</li> <li>脱离了 XHR，是 ES 规范里新的实现方式</li> <li>fetchtch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</li> <li>fetch 默认不会带 cookie，需要添加配置项</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以。</li></ul> <h3 id="xmlhttprequest"><a href="#xmlhttprequest" aria-hidden="true" class="header-anchor">#</a> XMLHttpRequest</h3> <p><code>xhrReq.open(method, url, async, user, password)</code></p> <p><code>readyState</code>:</p> <ul><li>0 UNSENT 代理被创建，但尚未调用 open() 方法。</li> <li>1 OPENED open() 方法已经被调用。</li> <li>2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。</li> <li>3 LOADING 下载中； responseText 属性已经包含部分数据。</li> <li>4 DONE 下载操作已完成。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="实现一个-bind"><a href="#实现一个-bind" aria-hidden="true" class="header-anchor">#</a> 实现一个 bind</h3> <h3 id="fragment"><a href="#fragment" aria-hidden="true" class="header-anchor">#</a> fragment</h3> <p><code>let fragment = document.createDocumentFragment();</code></p> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <h3 id="尾调用-2"><a href="#尾调用-2" aria-hidden="true" class="header-anchor">#</a> 尾调用</h3> <h3 id="weakmap-作用"><a href="#weakmap-作用" aria-hidden="true" class="header-anchor">#</a> WeakMap 作用</h3> <h3 id="for-in，object-keys-object-getownpropertynames-的区别"><a href="#for-in，object-keys-object-getownpropertynames-的区别" aria-hidden="true" class="header-anchor">#</a> for...in，Object.keys Object.getOwnPropertyNames 的区别</h3> <p>Object.getOwnPropertyNames(a) returns all own properties of the object a.
Object.keys(a) returns all enumerable own properties.
It means that if you define your object properties without making some of them enumerable: false these two methods will give you the same result.</p> <h3 id="css-in-js"><a href="#css-in-js" aria-hidden="true" class="header-anchor">#</a> css in js</h3> <h3 id="css-module"><a href="#css-module" aria-hidden="true" class="header-anchor">#</a> css module</h3> <h3 id="cookie-session"><a href="#cookie-session" aria-hidden="true" class="header-anchor">#</a> cookie session</h3> <p>cookie 不设置时间就是当浏览器全部关闭时失效
而 sessionStorage 是当 tab 关闭时就失效，tab 之间不共享。
有特殊例子：如通过 a 页面链接(或者用了 window.open)点开了 b 页面，它们之间是共享的。</p> <h3 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" aria-hidden="true" class="header-anchor">#</a> ES6 模块与 CommonJS 模块的差异</h3> <ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>CommonJS 模块的顶层 this 指向当前模块。ES6 模块之中，顶层的 this 指向 undefined，这是两者的一个重大差异。</li></ul> <p>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p> <h3 id="循环依赖加载加载问题"><a href="#循环依赖加载加载问题" aria-hidden="true" class="header-anchor">#</a> 循环依赖加载加载问题</h3> <p>CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  loaded<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p> <p>以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p> <p>es6</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//foo.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is running'</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./bar'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j after 500 ms'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is finished'</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//bar.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is running'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>bar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is finished'</span><span class="token punctuation">)</span>
</code></pre></div><p>结果：
bar is running
bar is finished
foo is running
bar = false
foo is finished
bar = true after 500 ms</p> <p>https://zhuanlan.zhihu.com/p/33049803</p> <h3 id="amd-cmd"><a href="#amd-cmd" aria-hidden="true" class="header-anchor">#</a> AMD CMD</h3> <ul><li>AMD 推崇依赖前置、提前执行</li> <li>CMD 推崇依赖就近、延迟执行</li></ul> <h3 id="module-exports-和-exports-区别"><a href="#module-exports-和-exports-区别" aria-hidden="true" class="header-anchor">#</a> module.exports 和 exports 区别</h3> <p>exports 就是 module.exports 的别名，是用来简化书写的</p> <h3 id="async-与-generator-区别"><a href="#async-与-generator-区别" aria-hidden="true" class="header-anchor">#</a> async 与 Generator 区别</h3> <ol><li><p>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。
也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p></li> <li><p>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p></li> <li><p>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，
而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p></li></ol> <h3 id="stopimmediatepropagation-vs-stoppropagation"><a href="#stopimmediatepropagation-vs-stoppropagation" aria-hidden="true" class="header-anchor">#</a> stopImmediatePropagation vs stopPropagation</h3> <p>stopPropagation()方法阻止事件对象移到到另一个节点上，但是允许当前节点的其他事件监听函数执行，而 stopImmediatePropagation()方法不仅阻止事件从当前节点移动到另一个节点上，它还不允许当前节点的其他事件监听函数执行。</p> <h3 id="serviceworker"><a href="#serviceworker" aria-hidden="true" class="header-anchor">#</a> serviceWorker</h3> <h3 id="重绘（repaint）和回流（reflow）"><a href="#重绘（repaint）和回流（reflow）" aria-hidden="true" class="header-anchor">#</a> 重绘（Repaint）和回流（Reflow）</h3> <h2 id="webpack-2"><a href="#webpack-2" aria-hidden="true" class="header-anchor">#</a> webpack</h2> <h2 id="babel"><a href="#babel" aria-hidden="true" class="header-anchor">#</a> babel</h2> <p>https://juejin.im/post/5d0373a95188251e1b5ebb6c</p> <h3 id="performance"><a href="#performance" aria-hidden="true" class="header-anchor">#</a> performance</h3> <p>js：压缩，拆分，tree-shaking，按需，gzip
css：压缩，按需，gzip
img：cdn，http cache
http：gzip dns-prefetch perload prefetch
svg: 压缩合并</p> <h3 id="document-的-load-事件和-domcontentloaded-事件之间的区别"><a href="#document-的-load-事件和-domcontentloaded-事件之间的区别" aria-hidden="true" class="header-anchor">#</a> document 的 load 事件和 DOMContentLoaded 事件之间的区别</h3> <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
load 事件仅在 DOM 和所有相关资源全部完成加载后才会触发。</p> <h3 id="sort-原理"><a href="#sort-原理" aria-hidden="true" class="header-anchor">#</a> sort 原理</h3> <p>chrome 当数组长度小于等于 10 的时候，采用插入排序，大于 10 的时候，采用快排。
其它有用归并排序的</p> <h2 id="浏览器相关知识"><a href="#浏览器相关知识" aria-hidden="true" class="header-anchor">#</a> 浏览器相关知识</h2> <h3 id="输入-url-发生了什么"><a href="#输入-url-发生了什么" aria-hidden="true" class="header-anchor">#</a> 输入 url 发生了什么</h3> <h3 id="http1-1-http2-0"><a href="#http1-1-http2-0" aria-hidden="true" class="header-anchor">#</a> http1.1 http2.0</h3> <p>https://www.nihaoshijie.com.cn/index.php/archives/698/
https://imququ.com/post/header-compression-in-http2.html</p> <h3 id="https"><a href="#https" aria-hidden="true" class="header-anchor">#</a> https</h3> <h3 id="tcp-udp"><a href="#tcp-udp" aria-hidden="true" class="header-anchor">#</a> tcp udp</h3> <p>tcp/ip 的并发限制</p> <h3 id="xmlhttprequest-2"><a href="#xmlhttprequest-2" aria-hidden="true" class="header-anchor">#</a> xmlHttpRequest</h3> <h3 id="http-catch"><a href="#http-catch" aria-hidden="true" class="header-anchor">#</a> http catch</h3> <h3 id="reflow-reprint"><a href="#reflow-reprint" aria-hidden="true" class="header-anchor">#</a> reflow reprint</h3> <p>渲染树的 reflow 或 repaint 的代价十分高昂，那么不得不采取一些优化的方式，浏览器对此有一些针对性的举措。一种策略便是延迟。浏览器会将一些变动放在一个队列中，当达到一定规模或者延迟的时间已到，那么会一次将这些变动反应到渲染树中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'blue'</span>

<span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token parameter">sleepDuration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> now <span class="token operator">+</span> sleepDuration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* do nothing */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'black'</span>
</code></pre></div><h3 id="浏览器内核"><a href="#浏览器内核" aria-hidden="true" class="header-anchor">#</a> 浏览器内核</h3> <p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p> <ul><li>GUI 渲染线程</li> <li>JavaScript 引擎线程</li> <li>定时触发器线程</li> <li>事件触发线程</li> <li>异步 http 请求线程</li></ul> <p>https://juejin.im/post/5c337ae06fb9a049bc4cd218</p> <h3 id="游览器缓存"><a href="#游览器缓存" aria-hidden="true" class="header-anchor">#</a> 游览器缓存</h3> <p>浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。</p> <table><thead><tr><th></th> <th>获取资源形式</th> <th>状态码</th> <th>发送请求到服务器</th></tr></thead> <tbody><tr><td>强缓存</td> <td>从缓存获取</td> <td>200(from cache)</td> <td>否，直接从缓存获取</td></tr> <tr><td>协商缓存</td> <td>从缓存获取</td> <td>304(Not Modified)</td> <td>否，通过服务器来通知缓存是否可用</td></tr></tbody></table> <p>Cache-control &gt; Expires &gt; eTag &gt; last-modified</p> <p>当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：</p> <ul><li>本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送 http 请求到服务器；</li> <li>协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个 http 请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回 304，让浏览器使用本地找到的那个资源；</li> <li>缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回 200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回 404。</li></ul> <p>Cache-control 主要是为了解决用户的系统时间改到这个标识的时间之后，就永远不会命中这个强制缓存的问题。</p> <p>eTag 主要为了解决 Last-Modified 无法解决的一些问题：</p> <p>1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；</p> <p>2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；</p> <p>3、某些服务器不能精确的得到文件的最后修改时间。</p> <p>If-Modified-Since 和 If-None-Match</p> <p><strong>延伸</strong>
from disk cache(磁盘缓存)和 from memory cache(内存缓存) 的区别？
浏览器自己的一个缓存策略。
一般性 css 都是 disk cache
script 是 memory cache
当文件比较大时也会存在 disk cache</p> <p><strong>Service Worker 缓存</strong></p> <p><a href="https://zhuanlan.zhihu.com/p/44789005" target="_blank" rel="noopener noreferrer">一文读懂前端缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="cdn"><a href="#cdn" aria-hidden="true" class="header-anchor">#</a> CDN</h3> <p>Content Delivery Network，即内容分发网络</p> <ul><li>用户访问 CDN 加速域名</li> <li>本地 DNS 进行域名解析</li> <li>本地 DNS 服务器将请求发送到网站 DNS 服务器，通过 CNAME 机制，请求指向 CDN 全球负载均衡集群</li> <li>负载均衡集群通过智能解析，为用户分配相应速度最快的节点，本地 DNS 将节点 IP 返回给用户</li> <li>用户对 CDN 节点进行请求</li></ul> <h3 id="dns"><a href="#dns" aria-hidden="true" class="header-anchor">#</a> DNS</h3> <p>Domain Name System 将域名和 IP 地址相互映射的一个分布式数据库
当浏览器访问一个域名的时候，需要解析一次 DNS，获得对应域名的 ip 地址。
浏览器缓存 =&gt; 系统缓存 =&gt; 路由器缓存 =&gt;ISP(运营商)DNS 缓存 =&gt; 根域名服务器 =&gt; 顶级域名服务器 =&gt; 主域名服务器的顺序
逐步读取缓存，直到拿到 IP 地址</p> <p>DNS 请求是走 UDP 的</p> <p>DNS 的预解析</p> <p>可以通过用 meta 信息来告知浏览器, 我这页面要做 DNS 预解析
<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></p> <p>可以使用 link 标签来强制对 DNS 做预解析:
<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://ke.qq.com/&quot; /&gt;</code></p> <p>淘宝使用了上述方案。</p> <h3 id="http"><a href="#http" aria-hidden="true" class="header-anchor">#</a> Http</h3> <p>HTTP 方法:
GET,POST,PUT,PATCH,DELETE,OPTIONS
不太常用：CONNECT,TRACE,HEAD</p> <p>PUT vs POST:
PUT 和 POST 方法的区别是,PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而 POST 方法是非幂等的。</p> <p>PUT vs PATCH:
PUT 和 PATCH 都是更新资源，而 PATCH 用来对已知资源进行局部更新。</p> <h3 id="http-status-code"><a href="#http-status-code" aria-hidden="true" class="header-anchor">#</a> http status code</h3> <ul><li>1xx：临时回应，表示客户端请继续。</li> <li>2xx：请求成功。
<ul><li>200：请求成功。</li> <li>201：该请求已成功，并因此创建了一个新的资源。这通常是在 PUT 发送的响应。</li> <li>202：请求已经接收到，但还未响应，没有结果。</li> <li>204：表示请求成功，但响应报文不含实体的主体部分</li> <li>206：大文件断点续传</li></ul></li> <li>3xx: 表示请求的目标有变化，希望客户端进一步处理。
<ul><li>301：永久性跳转</li> <li>302：临时性跳转</li> <li>303：对应当前请求的响应可以在另一个 URI 上被找到。</li> <li>304：跟客户端缓存没有更新。</li></ul></li> <li>4xx：客户端请求错误。
<ul><li>400：请求报文存在语法错误</li> <li>401：表示发送的请求需要有通过 HTTP 认证的认证信息</li> <li>403：服务器已经理解请求，但是拒绝执行它。</li> <li>404：表示请求的页面不存在。</li> <li>404：请求行中指定的请求方法不能被用于请求相应的资源</li> <li>408：请求超时。</li></ul></li> <li>5xx：服务端请求错误。
<ul><li>500：服务端错误。</li> <li>501：此请求方法不被服务器支持且无法被处理</li> <li>503：网关错误，服务端暂时性错误，可以一会再试。</li> <li>504：网关超时。</li></ul></li></ul> <h3 id="keep-alive"><a href="#keep-alive" aria-hidden="true" class="header-anchor">#</a> keep-alive</h3> <p>在早期的 HTTP/1.0 中，每次 http 请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引入了重用连接的机制，就是在 http 请求头中加入 Connection: keep-alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定 HTTP/1.0 如果想要保持长连接，需要在请求头中加上 Connection: keep-alive。
keep-alive 的优点：</p> <ul><li>较少的 CPU 和内存的使用（由于同时打开的连接的减少了）</li> <li>允许请求和应答的 HTTP 管线化</li> <li>降低拥塞控制 （TCP 连接减少了）</li> <li>减少了后续请求的延迟（无需再进行握手）</li> <li>报告错误无需关闭 TCP 连</li></ul> <p>可以设置 timeout=5, max=100</p> <h3 id="https-2"><a href="#https-2" aria-hidden="true" class="header-anchor">#</a> https</h3> <h3 id="http2"><a href="#http2" aria-hidden="true" class="header-anchor">#</a> http2</h3> <p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer">http/2 vs http/1.1 在线性能测试<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
有个成语叫“事出有因”，每个事物都有其存在的意义（原因），而 HTTP/2 的诞生自然来自于 HTTP/1 的一些痛点。</p> <p>https://github.com/amandakelake/blog/issues/35
https://github.com/creeperyang/blog/issues/23
https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</p> <h3 id="tpc"><a href="#tpc" aria-hidden="true" class="header-anchor">#</a> tpc</h3> <p>三次通信是理论上的最小值. 所以三次握手不是 TCP 本身的要求, 而是为了满足&quot;在不可靠信道上可靠地传输信息&quot;这一需求所导致的。</p> <p>一句话概括，TCP 连接握手，握的是啥？
通信双方数据原点的序列号！</p> <p>SYN：同步序列编号（Synchronize Sequence Numbers）
ACK: 认字符 (Acknowledgement)</p> <h3 id="upd"><a href="#upd" aria-hidden="true" class="header-anchor">#</a> upd</h3> <h3 id="端口号"><a href="#端口号" aria-hidden="true" class="header-anchor">#</a> 端口号</h3> <p>1024&lt; 端口 &lt; 65535</p> <h3 id="输入一个-url"><a href="#输入一个-url" aria-hidden="true" class="header-anchor">#</a> 输入一个 url</h3> <p>https://segmentfault.com/a/1190000019504744</p> <h2 id="移动端"><a href="#移动端" aria-hidden="true" class="header-anchor">#</a> 移动端</h2> <h3 id="fastclick"><a href="#fastclick" aria-hidden="true" class="header-anchor">#</a> fastClick</h3> <p>大致是说，移动浏览器 会在 touchend 和 click 事件之间，等待 300 - 350 ms，判断用户是否会进行双击手势用以缩放文字。
fastClick 源码大部分都是用来解决 iOS 各个版本各种奇奇怪怪的 BUG。</p> <p>解决方案:</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>viewport<span class="token punctuation">&quot;</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>user-scalable=no<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>或者</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">html</span> <span class="token punctuation">{</span>
  <span class="token property">touch-action</span><span class="token punctuation">:</span> manipulation<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>WKWebView 在 iOS 9.3 不需要</p> <p>或则要兼容老系统使用<code>fastClick</code></p> <p>相关文章：<a href="https://juejin.im/post/5ce764a2f265da1b8c19645a" target="_blank" rel="noopener noreferrer">2019 再聊移动端 300ms 延迟及 fastClick 原理解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="计算机基础"><a href="#计算机基础" aria-hidden="true" class="header-anchor">#</a> 计算机基础</h2> <h3 id="ascii-unicode，utf8，utf16"><a href="#ascii-unicode，utf8，utf16" aria-hidden="true" class="header-anchor">#</a> ASCII unicode，utf8，utf16</h3> <p>ASCII =&gt; unicode，utf8，utf16</p> <p>需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</p> <p>比如，汉字严的 Unicode 是十六进制数 4E25，转换成二进制数足足有 15 位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。</p> <p>这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是 0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</p> <p>UTF-16 比较好理解,就是任何字符对应的数字都用两个字节来保存。但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.</p> <p>于是又有个 UTF-8,这里的 8 非常容易误导人,8 不是指一个字节,难道一个字节表示一个字符?实际上不是.当用 UTF-8 时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过 3 个字节了.反正是根据字符对应的数字大小来确定.</p> <p>于是 UTF-8 和 UTF-16 的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用 UTF-8 就比 UTF-16 节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16 就占优势了,可以节省很多空间</p> <p>http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</p> <h3 id="png8-png24-png32"><a href="#png8-png24-png32" aria-hidden="true" class="header-anchor">#</a> PNG8 PNG24 PNG32</h3> <p>PNG8：PNG 8 中的 8，其实指的是 8bits，相当于用 2^8（2 的 8 次方）大小来存储一张图片的颜色种类，2^8 等于 256，也就是说 PNG 8 能存储 256 种颜色，一张图片如果颜色种类很少，将它设置成 PNG 8 得图片类型是非常适合的。</p> <p>PNG24：PNG 24 中的 24，相当于 3 乘以 8 等于 24，就是用三个 8bits 分别去表示 R（红）、G（绿）、B（蓝）。R(0~255),G(0~255),B(0~255)，可以表达 256 乘以 256 乘以 256=16777216 种颜色的图片，这样 PNG 24 就能比 PNG 8 表示色彩更丰富的图片。但是所占用的空间相对就更大了。</p> <p>PNG32：PNG 32 中的 32，相当于 PNG 24 加上 8bits 的透明颜色通道，就相当于 R（红）、G（绿）、B（蓝）、A（透明）。</p> <h3 id="png-压缩"><a href="#png-压缩" aria-hidden="true" class="header-anchor">#</a> PNG 压缩</h3> <p>PNG 图片的压缩，分两个阶段：</p> <ul><li>预解析：
png 图片用差分编码（Delta encoding）对图片进行预处理，处理每一个的像素点中每条通道的值，差分编码主要有几种：</li> <li>压缩：
压缩阶段会将预处理阶段得到的结果进行 Deflate 压缩，它由 Huffman 编码 和 LZ77 压缩构成。
如前面所说，Deflate 压缩会标记图片所有的重复数据，并记录数据特征和结构，会得到一个压缩比最大的 png 图片 编码数据。</li></ul> <h3 id="进程-线程"><a href="#进程-线程" aria-hidden="true" class="header-anchor">#</a> 进程 线程</h3> <p>进程是 CPU 资源分配的最小单位
线程是 CPU 调度的最小单位</p> <p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线</p> <p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。
当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p> <h3 id="网络七层协议"><a href="#网络七层协议" aria-hidden="true" class="header-anchor">#</a> 网络七层协议</h3> <p>物理层
数据链路层
网络层
传输层
表示层
会话层
应用层</p> <h3 id="tcp-ip-模型"><a href="#tcp-ip-模型" aria-hidden="true" class="header-anchor">#</a> TCP/IP 模型</h3> <p>网络接口
网络层传输层
传输层
应用层</p> <h3 id="不可变数据"><a href="#不可变数据" aria-hidden="true" class="header-anchor">#</a> 不可变数据</h3> <p>很多对象和数组的操作都是有副作用的，一不小心就会导致错误。</p> <p>可变的好处是节省内存或是利用可变性做一些事情，但是，在复杂的开发中它的副作用远比好处大的多。于是才有了浅 copy 和深 copy，就是为了解决这个问题。</p> <p>Immutable.js 的实现原理：
Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p> <p>主要好处：没有副作用，节省内存，容易时间回溯</p> <p>immer 原理：
immer 的做法就是维护一份 state 在内部，劫持所有操作，内部来判断是否有变化从而最终决定如何返回。</p> <p><a href="https://zhangzhao.name/posts/immer-immutable/" target="_blank" rel="noopener noreferrer">更简单，更快速的创建不可变数据类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="diff-原理"><a href="#diff-原理" aria-hidden="true" class="header-anchor">#</a> diff 原理</h3> <h2 id="网络安全"><a href="#网络安全" aria-hidden="true" class="header-anchor">#</a> 网络安全</h2> <h3 id="sql-注入攻击-sql-injection"><a href="#sql-注入攻击-sql-injection" aria-hidden="true" class="header-anchor">#</a> SQL 注入攻击(SQL Injection)</h3> <h3 id="命令行注入-command-execution"><a href="#命令行注入-command-execution" aria-hidden="true" class="header-anchor">#</a> 命令行注入 Command Execution</h3> <p>原理和 SQL 注入攻击类似</p> <h3 id="file-upload-vulnerabilities"><a href="#file-upload-vulnerabilities" aria-hidden="true" class="header-anchor">#</a> File Upload Vulnerabilities</h3> <h3 id="开放重定向-open-redirects"><a href="#开放重定向-open-redirects" aria-hidden="true" class="header-anchor">#</a> 开放重定向 Open Redirects</h3> <h3 id="xss-跨站脚本攻击-cross-site-scripting"><a href="#xss-跨站脚本攻击-cross-site-scripting" aria-hidden="true" class="header-anchor">#</a> XSS 跨站脚本攻击 (Cross-site Scripting)</h3> <p>XSS 的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。
XSS 有哪些注入的方法：</p> <ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li> <li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li> <li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li> <li>在标签的 href、src 等属性中，包含 javascript: 等可执行代码。</li> <li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li> <li>在 style 属性和标签中，包含类似 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范）。</li> <li>在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul> <p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p> <h3 id="跨站请求伪造-csrf（cross-site-request-forgery"><a href="#跨站请求伪造-csrf（cross-site-request-forgery" aria-hidden="true" class="header-anchor">#</a> 跨站请求伪造 CSRF（Cross-site request forgery)</h3> <p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p> <p>https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Forms/Sending_and_retrieving_form_data#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98</p> <h3 id="点击劫持-click-jacking"><a href="#点击劫持-click-jacking" aria-hidden="true" class="header-anchor">#</a> 点击劫持 Click Jacking</h3> <p>也叫 UI 覆盖攻击，攻击者会利用一个或多个透明或不透明的层来诱骗用户支持点击按钮的操作，而实际的点击确实用户看不到的一个按钮，从而达到在用户不知情的情况下实施攻击。</p> <p>可以设置<code>X-Frame-Options</code>进行防御或者设置<code>content-security-policy</code></p> <h3 id="一些建议"><a href="#一些建议" aria-hidden="true" class="header-anchor">#</a> 一些建议</h3> <p>使用 https，任何东西不要使用明文传输。</p> <p>在登录或者忘记密码的地方，不要提示是邮箱不正确还是密码不正确。这样会大大减少黑客的破解难度。
如 twitter，登录时只提示邮箱和密码不匹配，并不会告诉你到底是哪一个不对。</p> <p>尽量不要自建登录系统，可以多依托于一些第三方的登录，如微博、QQ 等。</p> <p>使用 a 标签跳槽的时候加上 <code>rel=&quot;noopener noreferrer&quot;</code></p> <h2 id="flutter-vs-react-native"><a href="#flutter-vs-react-native" aria-hidden="true" class="header-anchor">#</a> flutter vs react native</h2> <p>谷歌大会上</p> <p>react native 使用 js 编写，生成虚拟 dom，最后它将你转化为 iOS 或者 Android 原生组件。而 Flutter 是基于 <code>Skia</code> 实现的。没有什么 Android runtime 或者 Chromium 什么中间层。</p> <p>dart 语言上的优势。类 java 强类型 oop 语言，AOT(Ahead-Of-Time )</p> <h3 id="前端代码安全"><a href="#前端代码安全" aria-hidden="true" class="header-anchor">#</a> 前端代码安全</h3> <p>可以使用 <a href="https://obfuscator.io/" target="_blank" rel="noopener noreferrer">JavaScript Obfuscator Tool<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> js 代码混淆工具，但只是增加了一些破解成本，WebAssembly 安全性相对而言更好。相关文章<a href="https://zhuanlan.zhihu.com/p/61651310" target="_blank" rel="noopener noreferrer">前端核心代码保护技术面面观<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="实现-foreach-polyfill"><a href="#实现-foreach-polyfill" aria-hidden="true" class="header-anchor">#</a> 实现 forEach polyfill</h3> <h3 id="多线程和单线程"><a href="#多线程和单线程" aria-hidden="true" class="header-anchor">#</a> 多线程和单线程</h3> <p>js 为什么要设计成单线程？
浏览器的内核是多线程
web worker -comlink</p> <p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p> <p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象</p> <h3 id="settimeout-vs-setinterval-区别"><a href="#settimeout-vs-setinterval-区别" aria-hidden="true" class="header-anchor">#</a> setTimeout vs setInterval 区别</h3> <p>衍生问题 setTimeout(func, 0)</p> <h3 id="函数节流-防抖"><a href="#函数节流-防抖" aria-hidden="true" class="header-anchor">#</a> 函数节流 防抖</h3> <h3 id="requestanimationframe"><a href="#requestanimationframe" aria-hidden="true" class="header-anchor">#</a> requestAnimationFrame</h3> <h3 id="eval-vs-new-function"><a href="#eval-vs-new-function" aria-hidden="true" class="header-anchor">#</a> eval vs new Function</h3> <h3 id="_1-2-3-map-parseint"><a href="#_1-2-3-map-parseint" aria-hidden="true" class="header-anchor">#</a> ['1', '2', '3'].map(parseInt)</h3> <h3 id="待看"><a href="#待看" aria-hidden="true" class="header-anchor">#</a> 待看</h3> <p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question" target="_blank" rel="noopener noreferrer">木易杨-高级前端进阶<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener noreferrer">leetcode<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="defer-vs-async"><a href="#defer-vs-async" aria-hidden="true" class="header-anchor">#</a> defer vs async</h3> <p><img src="https://wpimg.wallstcn.com/2dd76605-8008-479d-9415-e1fed67f9660.png" alt></p> <h3 id="跨项目使用代码"><a href="#跨项目使用代码" aria-hidden="true" class="header-anchor">#</a> 跨项目使用代码</h3> <ul><li>npm</li> <li>[bit](https://github.com/teambit/bit</li> <li>git module</li> <li>Monorepo</li></ul> <h2 id="json-边界问题"><a href="#json-边界问题" aria-hidden="true" class="header-anchor">#</a> json 边界问题</h2> <p>U+2028 U+2029</p> <p>JSON 支持，但在 js 中的 JSON 就不支持。</p> <p><a href="https://zhuanlan.zhihu.com/p/29958439" target="_blank" rel="noopener noreferrer">JSON: 不要误会,我真的不是 JavaScript 的子集<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="https-3"><a href="#https-3" aria-hidden="true" class="header-anchor">#</a> https</h2> <h2 id="http2-2"><a href="#http2-2" aria-hidden="true" class="header-anchor">#</a> http2</h2> <p>http2 头部压缩</p> <p>服务器端渲染 vs 预渲染 (SSR vs Prerendering)</p> <h2 id="beacon"><a href="#beacon" aria-hidden="true" class="header-anchor">#</a> Beacon</h2> <h2 id="前端监控"><a href="#前端监控" aria-hidden="true" class="header-anchor">#</a> 前端监控</h2> <p>https://juejin.im/post/5b35921af265da598f1563cf</p> <h2 id="api"><a href="#api" aria-hidden="true" class="header-anchor">#</a> API</h2> <h3 id="mutationobserver"><a href="#mutationobserver" aria-hidden="true" class="header-anchor">#</a> MutationObserver</h3> <h3 id="intersectionobserver"><a href="#intersectionobserver" aria-hidden="true" class="header-anchor">#</a> IntersectionObserver</h3> <h2 id="web-worker"><a href="#web-worker" aria-hidden="true" class="header-anchor">#</a> web worker</h2> <h3 id="lru-缓存算法"><a href="#lru-缓存算法" aria-hidden="true" class="header-anchor">#</a> LRU 缓存算法</h3> <h2 id="webpack-3"><a href="#webpack-3" aria-hidden="true" class="header-anchor">#</a> webpack</h2> <h3 id="tree-shaking-2"><a href="#tree-shaking-2" aria-hidden="true" class="header-anchor">#</a> tree shaking</h3> <h3 id="hot-reload-原理"><a href="#hot-reload-原理" aria-hidden="true" class="header-anchor">#</a> hot reload 原理</h3> <h3 id="节流与防抖"><a href="#节流与防抖" aria-hidden="true" class="header-anchor">#</a> 节流与防抖</h3> <h2 id="垃圾回收"><a href="#垃圾回收" aria-hidden="true" class="header-anchor">#</a> 垃圾回收</h2> <h2 id="js-双精度问题"><a href="#js-双精度问题" aria-hidden="true" class="header-anchor">#</a> js 双精度问题</h2> <h3 id="js-数值的最大最小值范围"><a href="#js-数值的最大最小值范围" aria-hidden="true" class="header-anchor">#</a> js 数值的最大最小值范围</h3> <h2 id="算法"><a href="#算法" aria-hidden="true" class="header-anchor">#</a> 算法</h2> <p>bds dfs
尾调用
五大算法
动态规划 #62 #70 #198 #91
分治算法
回溯法 #78 #22 #55(4 中解法) #39</p> <p>矩阵旋转</p> <p>游标记录位置 #283</p> <p>位运算 #371</p> <h3 id="vue-scoped-css-module"><a href="#vue-scoped-css-module" aria-hidden="true" class="header-anchor">#</a> vue scoped css module</h3> <h2 id="私有-npm"><a href="#私有-npm" aria-hidden="true" class="header-anchor">#</a> 私有 npm</h2> <h2 id="es6"><a href="#es6" aria-hidden="true" class="header-anchor">#</a> ES6</h2> <p>BigInt</p> <h2 id="flutter-vs-react-native-2"><a href="#flutter-vs-react-native-2" aria-hidden="true" class="header-anchor">#</a> flutter vs react native</h2> <h2 id="mvc-mvvm-mvp"><a href="#mvc-mvvm-mvp" aria-hidden="true" class="header-anchor">#</a> MVC MVVM MVP</h2> <h2 id="js-基础-2"><a href="#js-基础-2" aria-hidden="true" class="header-anchor">#</a> js 基础</h2> <h3 id="如何提升-json-stringify-的性能"><a href="#如何提升-json-stringify-的性能" aria-hidden="true" class="header-anchor">#</a> 如何提升 JSON.stringify()的性能</h3> <h2 id="计算机基础-2"><a href="#计算机基础-2" aria-hidden="true" class="header-anchor">#</a> 计算机基础</h2> <h3 id="uuid"><a href="#uuid" aria-hidden="true" class="header-anchor">#</a> uuid</h3> <p>UUID 是由一组 32 位数的 16 进制数字所构成。通用唯一标识符还可以用来指向大多数的可能的物体。微软和其他一些软件公司都倾向使用全球唯一标识符（GUID），这也是通用唯一标识符的一种类型，可用来指向组建对象模块对象和其他的软件组件</p> <h3 id="面向对象"><a href="#面向对象" aria-hidden="true" class="header-anchor">#</a> 面向对象</h3> <h3 id="js-ioc"><a href="#js-ioc" aria-hidden="true" class="header-anchor">#</a> js ioc</h3> <h2 id="react-相关"><a href="#react-相关" aria-hidden="true" class="header-anchor">#</a> React 相关</h2> <p>hooks 原理</p> <p>async function 判断
node 的循环依赖
position fixed 定位问题</p> <h2 id="正则"><a href="#正则" aria-hidden="true" class="header-anchor">#</a> 正则</h2> <p>[^a-za-z]</p> <p>https://juejin.im/post/5965943ff265da6c30653879</p> <p>验证身份证</p> <h2 id="面试集锦"><a href="#面试集锦" aria-hidden="true" class="header-anchor">#</a> 面试集锦</h2> <ul><li><p><a href="http://www.imooc.com/article/4379" target="_blank" rel="noopener noreferrer">如何面试前端工程师：Github 很重要<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://juejin.im/post/5aa7d82c6fb9a028c522de43" target="_blank" rel="noopener noreferrer">几道 JS 代码手写题以及一些代码实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://github.com/lydiahallie/javascript-questions" target="_blank" rel="noopener noreferrer">javascript-questions<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 一些简单的前端问题</p></li> <li><p><a href="https://github.com/lidaguang1989/frontent-interview/blob/master/javascript.md" target="_blank" rel="noopener noreferrer">面试大纲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul> <h2 id="其它问题"><a href="#其它问题" aria-hidden="true" class="header-anchor">#</a> 其它问题</h2> <h3 id="前端进阶"><a href="#前端进阶" aria-hidden="true" class="header-anchor">#</a> 前端进阶</h3> <h3 id="职业发展"><a href="#职业发展" aria-hidden="true" class="header-anchor">#</a> 职业发展</h3> <h3 id="你有什么想问的"><a href="#你有什么想问的" aria-hidden="true" class="header-anchor">#</a> 你有什么想问的</h3> <h3 id="npm-私有仓库"><a href="#npm-私有仓库" aria-hidden="true" class="header-anchor">#</a> npm 私有仓库</h3> <p>目前使用的是 Nexus 和安卓管理 maven 的东西放在一起
或者可以使用社区方案： verdaccio</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/PanJiaChen/awesome-bookmarks/edit/master/docs/interview/remember/README.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">6/27/2019, 6:46:48 AM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/awesome-bookmarks/assets/js/app.14090382.js" defer></script><script src="/awesome-bookmarks/assets/js/60.0c78edc4.js" defer></script>
  </body>
</html>
